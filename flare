#!/bin/sh
# Flare - A portable markdown notebook runner
# This script parses markdown files and executes code blocks based on tags

set -e

VERSION="0.1.0"

# Print usage information
print_usage() {
  echo "Flare - A portable markdown notebook runner v$VERSION"
  echo ""
  echo "Usage: flare [markdown_file] [subcommand]"
  echo ""
  echo "If no subcommand is provided, lists all available subcommands in the notebook."
  echo "If a subcommand is provided, executes all code blocks tagged with that subcommand."
  echo ""
  echo "Examples:"
  echo "  flare notebook.md         # List all available commands in notebook.md"
  echo "  flare notebook.md test    # Run all code blocks tagged with [test]"
}

# Check if there are enough arguments
if [ $# -lt 1 ]; then
  print_usage
  exit 1
fi

NOTEBOOK=$1
COMMAND=$2

# Check if notebook file exists
if [ ! -f "$NOTEBOOK" ]; then
  echo "Error: Notebook file '$NOTEBOOK' not found."
  exit 1
fi

# List all available commands in the notebook
list_commands() {
  echo "Available commands in $NOTEBOOK:"
  # Use grep to find all code blocks with tags, then extract just the tag names
  grep -o '\[[a-zA-Z0-9_-]*\]' "$NOTEBOOK" | sort | uniq | sed 's/\[//;s/\]//' | while read -r cmd; do
    echo "  $cmd"
  done
  printf "\nRun again with a command to execute the right code block.\n"
}

# Execute code blocks for a specific command
execute_command() {
  local command=$1
  local found=0
  local in_block=0
  local block=""
  local interpreter="/bin/sh"  # Default interpreter
  
  # Process the file line by line
  while IFS= read -r line || [ -n "$line" ]; do
    # Check for the start of a code block with our command
    if echo "$line" | grep -q "^\`\`\`.*\[$command\]"; then
      in_block=1
      found=1
      block=""
      
      # Extract the interpreter if specified
      if echo "$line" | grep -q "{.*}"; then
        interpreter=$(echo "$line" | sed 's/.*{\(.*\)}.*/\1/')
      fi
      continue
    fi
    
    # Check for the end of a code block
    if [ $in_block -eq 1 ] && echo "$line" | grep -q "^\`\`\`$"; then
      in_block=0
      
      # Create temporary file for the code block
      tempfile=$(mktemp)
      echo "$block" > "$tempfile"
      
      # Execute the code block with the specified interpreter
      echo "Executing $command block with $interpreter..."
      $interpreter "$tempfile"
      
      # Clean up
      rm "$tempfile"
      
      continue
    fi
    
    # Collect lines inside the code block
    if [ $in_block -eq 1 ]; then
      block="$block$line
"
    fi
  done < "$NOTEBOOK"
  
  if [ $found -eq 0 ]; then
    echo "Error: No code blocks found for command '$command'."
    echo "Available commands:"
    list_commands
    exit 1
  fi
}

# Main execution logic
if [ -z "$COMMAND" ]; then
  list_commands
else
  execute_command "$COMMAND"
fi